#!/usr/bin/env bash
#
# https://github.com/sandorex/config
# task management script version 3
#
# optional dependency: glow

set -eu

TASK_DIR="${TASK_DIR:-$HOME/.tasks}"
TASK_LINK="$HOME/.task"

# ISO8601 format without the extra characters
DATE_FMT="%Y%m%dT%H%M"

# set default editor globally
EDITOR=${TASK_EDITOR:-${EDITOR:-vi}}

# ensure it exists
mkdir -p "$TASK_DIR"

show_help() {
    cat <<EOF
Usage: $(basename "$0") <command> [<args..>]

Commands (uppercase letters are shorthand for that command):
    help       - Prints help message including some additional information
    Current    - Prints current task name, if no task is selected then exit
                 code is 1 and prints nothing
    new        - Creates new task
    Drop       - Unsets the current task
    select     - Selects a task, argument is task name, if no task name is
                 provided then user picks from a list
    Log        - Adds new log entry to the task then opens editor, arguments
                 are entry tags
    Status     - Shows the latest log entry
    show/ss    - Shows all the log entries concatenated into one file
    Edit       - Edit latest log entry
    summary/su - Shows latest log entry for each task, arguments are tasks to
                 show latest log if none are provided then shows for all tasks
    list/ls    - Lists all tasks, number of entries, date of latest entry

EOF
}

# do not use glow if outputting to a pipe
if [[ ! -p /dev/stdout ]] && command -v glow &>/dev/null; then
    HAS_GLOW=1
fi

is_task_selected() { [[ -e "$TASK_LINK" ]]; }

ensure_task_is_selected() {
    if ! is_task_selected; then
        echo "No task is selected"
        exit 1
    fi
}

get_task_path() { readlink "$TASK_LINK"; }
get_selected_task_name() { basename "$(get_task_path)"; }

get_tasks() {
    tasks=( "$TASK_DIR"/*/ )
    if [[ "${tasks[0]}" == "$TASK_DIR/*/" ]]; then
        return 1
    fi

    echo "${tasks[*]}"
}

get_task_entries() {
    path="${1:-$(get_task_path)}"
    entries=( "$path"/* )
    if [[ "${entries[0]}" == "$path/*" ]]; then
        return 1
    fi

    echo "${entries[*]}"
}

get_last_task_entry() {
    # shellcheck disable=SC2207
    if ! entries=( $(get_task_entries "${1:-}") ); then
        return 1
    fi

    echo "${entries[-1]}"
}

# remove the command from the arguments
CMD="${1:-""}"
shift || true

case "$CMD" in
    help)
        show_help

        # show additional information if help command is ran
        cat <<EOF
Options
    TASK_DIR=$TASK_DIR
    EDITOR=$EDITOR

Customization
    Editor is set to either \$TASK_EDITOR, \$EDITOR or 'vi' in order
    Task directory is controlled using \$TASK_DIR, defaults to '~/.task'

EOF
        exit
        ;;
    c|current)
        # the command should be empty when no task is set
        ensure_task_is_selected &>/dev/null

        get_selected_task_name
        ;;
    new)
        name="${1:-}"
        if [[ -z "$name" ]]; then
            echo "Please enter name of the new task"
            exit 1
        fi

        if [[ -e "$TASK_DIR/$name" ]]; then
            echo "Task '$name' already exists"
            exit 1
        fi

        echo "Creating new task '$name'"
        mkdir -p "$TASK_DIR/$name"
        ;;
    d|drop|unset) # 'unset' for compatbility sake
        ensure_task_is_selected

        echo "Dropping current task '$(get_selected_task_name)'"
        rm -f "$TASK_LINK"
        ;;
    select|set) # i kept 'set' for compatibilty sake
        task="${1:-}"
        if [[ -z "$task" ]]; then
            if ! tasks=( $(get_tasks) ); then
                echo "There are no tasks found"
                exit 1
            fi

            # TODO make the tasks the name only not a full path
            select i in "${tasks[@]}"; do
                task=$(basename "$i")
                break
            done
        fi

        if [[ ! -d "$TASK_DIR/$task" ]]; then
            echo "Task '$task' does not exist"
            exit 1
        fi

        echo "Setting task '$task' as the current task"
        ln -sf "$TASK_DIR/$task" "$TASK_LINK"
        ;;
    status|s)
        ensure_task_is_selected

        if ! file="$(get_last_task_entry)"; then
            echo "There is no task entries in task '$(get_selected_task_name)'"
            exit 1
        fi
        if [[ -n "$HAS_GLOW" ]]; then
            glow --local "$file"
        else
            less "$file"
        fi
        ;;
    l|log)
        ensure_task_is_selected

        TAGS=( )
        while [ $# -gt 0 ]; do
            # turn tag uppercase
            TAGS+=( "${1^^}" )
            shift
        done

        # using full path so the editor remembers it regardless of current task
        file="$(readlink "$TASK_LINK")/$(date +"$DATE_FMT").md"

        # only create it if it does not already exists
        if [[ ! -e "$file" ]]; then
            # create it in case it was deleted or something but still selected
            mkdir -p "$(get_task_path)"

            cat <<EOF > "$file"

## ${TAGS[*]}${TAGS:+ }$(date +"$DATE_FMT")
EOF
        fi

        command "$EDITOR" "$file"
        ;;
    list|ls)
        if ! tasks=( $(get_tasks) ); then
            echo "There are no tasks found"
            exit 1
        fi

        for task in "${tasks[@]}"; do
            printf "%s\n" "$(basename "$task")"
        done
        ;;
    summary|su)
        for task in $(get_tasks); do
            echo "Task '$(basename "$task")':"

            # in case the task has no entries just dont do anything
            if ! last_entry="$(get_last_task_entry "$task")"; then
                continue
            fi

            if [[ -n "$HAS_GLOW" ]]; then
                glow --local "$last_entry"
            else
                less "$last_entry"
            fi
        done
        ;;
    show|ss)
        # shouldnt print anything on error
        ensure_task_is_selected 1>&2

        if ! get_task_entries &>/dev/null; then
            echo "There is no task entries in task '$(get_selected_task_name)'" 1>&2
            exit 1
        fi

        concat() {
            echo "## Task $(get_selected_task_name)"
            cat "$(get_task_path)"/*
        }

        if [[ -n "$HAS_GLOW" ]]; then
            concat | glow --local
        else
            concat | less
        fi
        ;;
    e|edit)
        ensure_task_is_selected

        # automatically create new log entry if there are none
        if ! last_entry="$(get_last_task_entry)"; then
            exec "$0" log
        fi

        command "$EDITOR" "$last_entry"
        ;;
    *)
        echo "Invalid command"
        show_help
        exit 1
        ;;
esac

